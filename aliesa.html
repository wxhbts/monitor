<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="https://cdn.cydiaa.com/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é˜¿é‡Œäº‘ESA ç›‘æ§å¤§å±</title>
	<script>
        // ç«‹å³æ‰§è¡Œï¼Œæ£€æŸ¥æœ¬åœ°å­˜å‚¨æˆ–ç³»ç»Ÿåå¥½
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <!-- Tailwind CSS for Shadcn/UI style -->
    <script src="https://eo.cydiaa.com/?url=https://cdn.tailwindcss.com"></script>
    <script src="https://eo.cydiaa.com/?url=https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://eo.cydiaa.com/?url=https://cdn.jsdelivr.net/npm/echarts@4.9.0/map/js/world.js"></script>
    <style>
        @import url('https://eo.cydiaa.com/?url=https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        border: "hsl(var(--border))",
                        input: "hsl(var(--input))",
                        ring: "hsl(var(--ring))",
                        background: "hsl(var(--background))",
                        foreground: "hsl(var(--foreground))",
                        primary: {
                            DEFAULT: "hsl(var(--primary))",
                            foreground: "hsl(var(--primary-foreground))",
                        },
                        secondary: {
                            DEFAULT: "hsl(var(--secondary))",
                            foreground: "hsl(var(--secondary-foreground))",
                        },
                        destructive: {
                            DEFAULT: "hsl(var(--destructive))",
                            foreground: "hsl(var(--destructive-foreground))",
                        },
                        muted: {
                            DEFAULT: "hsl(var(--muted))",
                            foreground: "hsl(var(--muted-foreground))",
                        },
                        accent: {
                            DEFAULT: "hsl(var(--accent))",
                            foreground: "hsl(var(--accent-foreground))",
                        },
                        popover: {
                            DEFAULT: "hsl(var(--popover))",
                            foreground: "hsl(var(--popover-foreground))",
                        },
                        card: {
                            DEFAULT: "hsl(var(--card))",
                            foreground: "hsl(var(--card-foreground))",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                },
            },
        }
    </script>
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 222.2 84% 4.9%;
            --primary: 222.2 47.4% 11.2%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 210 40% 98%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 222.2 84% 4.9%;
            --radius: 0.75rem; /* Changed from 0.5rem for consistency with cf.html */
        }

        /* ğŸŒ™ å¤œé—´æ¨¡å¼ */
        html.dark {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --popover: 240 10% 3.9%;
            --popover-foreground: 0 0% 98%;
            --primary: 212 100% 68%;
            --primary-foreground: 0 0% 9%;
            --secondary: 240 3.7% 15.9%;
            --secondary-foreground: 0 0% 98%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 0 0% 63.9%;
            --accent: 240 3.7% 15.9%;
            --accent-foreground: 0 0% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 0 0% 98%;
            --border: 240 3.7% 15.9%;
            --input: 240 3.7% 15.9%;
            --ring: 212 100% 68%;
            --chart-1: 212 100% 68%;
            --chart-2: 0 0% 50%;
            --chart-3: 30 80% 55%;
            --chart-4: 280 65% 60%;
            --chart-5: 340 75% 55%;
            --radius: 0.75rem;
            --sidebar-background: 240 5.9% 10%;
            --sidebar-foreground: 240 4.8% 95.9%;
            --sidebar-primary: 224.3 76.3% 48%;
            --sidebar-primary-foreground: 0 0% 100%;
            --sidebar-accent: 240 3.7% 15.9%;
            --sidebar-accent-foreground: 240 4.8% 95.9%;
            --sidebar-border: 240 3.7% 15.9%;
            --sidebar-ring: 217.2 91.2% 59.8%;
			
            *, ::after, ::before {
                border-color: hsl(var(--border));
            }
        }
    </style>
</head>
<body class="bg-background text-foreground min-h-screen p-8 transition-colors">
    <!-- Loading Progress Bar -->
    <div id="loading-progress-container" class="fixed top-0 left-0 w-full h-1 z-50 bg-transparent pointer-events-none">
        <div id="loading-progress-bar" class="h-full bg-blue-500 transition-all duration-300 ease-out w-0"></div>
    </div>
    <div class="max-w-7xl mx-auto space-y-8">
        
        <!-- Header -->
        <div class="flex items-center justify-between">
            <div>
                <h1 id="page-header" class="text-3xl font-bold tracking-tight text-foreground">é˜¿é‡Œäº‘ESA ç›‘æ§å¤§å±</h1>
                <p class="text-muted-foreground mt-1">é˜¿é‡Œäº‘ESA ç«™ç‚¹æµé‡ä¸è¯·æ±‚é‡åˆ†æ</p>
            </div>
            <!-- ğŸŒ™ å¤œé—´æ¨¡å¼æŒ‰é’® -->
            <button
                id="themeToggle"
                onclick="toggleTheme()"
                class="h-9 px-4 rounded-md border bg-card text-card-foreground hover:bg-accent transition text-sm"
            >
                ğŸŒ™ å¤œé—´æ¨¡å¼
            </button>
        </div>

        <!-- Time Controls -->
        <div class="flex flex-wrap items-center gap-4 bg-card p-4 rounded-xl border border-border shadow-sm transition-colors">
            <div class="flex items-center space-x-2">
                <label for="timeRange" class="text-sm font-medium text-foreground">æ—¶é—´èŒƒå›´:</label>
                <select id="timeRange" onchange="handleTimeRangeChange()" class="h-9 w-[180px] rounded-md
         rounded-md border border-border
         bg-background text-foreground
         px-3 py-1 text-sm shadow-sm
         transition-colors
         focus-visible:outline-none
         focus-visible:ring-1
         focus-visible:ring-ring">
                    <option value="30min">è¿‘ 30 åˆ†é’Ÿ</option>
                    <option value="1h">è¿‘ 1 å°æ—¶</option>
                    <option value="6h">è¿‘ 6 å°æ—¶</option>
                    <option value="today">ä»Šæ—¥</option>
                    <option value="yesterday">æ˜¨æ—¥</option>
                    <option value="3d">è¿‘ 3 å¤©</option>
                    <option value="7d">è¿‘ 7 å¤©</option>
                    <option value="14d">è¿‘ 14 å¤©</option>
                    <option value="31d">è¿‘ 31 å¤©</option>
                    <option value="custom">è‡ªå®šä¹‰</option>
                </select>
            </div>
            <!-- Custom Time Inputs -->
            <div id="customTimeInputs" class="hidden flex-wrap items-center gap-2 mt-2 w-full sm:w-auto">
                <div class="flex items-center space-x-1">
                    <input type="number" id="customDays" placeholder="0" class="h-8 w-16 rounded-md border border-border bg-background text-foreground px-2 text-sm" min="0" max="31">
                    <span class="text-xs">å¤©</span>
                </div>
                <div class="flex items-center space-x-1">
                    <input type="number" id="customHours" placeholder="0" class="h-8 w-16 rounded-md border border-border bg-background text-foreground px-2 text-sm" min="0" max="23">
                    <span class="text-xs">å°æ—¶</span>
                </div>
                <div class="flex items-center space-x-1">
                    <input type="number" id="customMinutes" placeholder="0" class="h-8 w-16 rounded-md border border-border bg-background text-foreground px-2 text-sm" min="0" max="59">
                    <span class="text-xs">åˆ†</span>
                </div>
                <div class="flex items-center space-x-1">
                    <input type="number" id="customSeconds" placeholder="0" class="h-8 w-16 rounded-md border border-border bg-background text-foreground px-2 text-sm" min="0" max="59">
                    <span class="text-xs">ç§’</span>
                </div>
                <button onclick="refreshData()" class="h-8 px-3 bg-primary text-primary-foreground rounded-md text-xs hover:bg-primary/90">åº”ç”¨</button>
                <span id="timeRangeError" class="text-red-500 text-xs font-medium ml-2"></span>
            </div>
            <div class="flex items-center space-x-2">
                <label for="interval" class="text-sm font-medium text-foreground">ç²’åº¦:</label>
                <select id="interval" onchange="refreshData()" class="h-9 w-[180px] rounded-md
         rounded-md border border-border
         bg-background text-foreground
         px-3 py-1 text-sm shadow-sm
         transition-colors
         focus-visible:outline-none
         focus-visible:ring-1
         focus-visible:ring-ring">
                    <option value="auto" selected>è‡ªåŠ¨</option>
                    <option value="60">1 åˆ†é’Ÿ</option>
                    <option value="300">5 åˆ†é’Ÿ</option>
                    <option value="3600">1 å°æ—¶</option>
                    <option value="86400">1 å¤©</option>
                </select>
            </div>
            <div class="flex items-center space-x-2">
    <label for="cdnSelector" class="text-sm font-medium text-foreground">CDNæœåŠ¡å•†:</label>
    <select id="cdnSelector" onchange="if(this.value) window.location.href=this.value" class="h-9 w-[240px] rounded-md
         rounded-md border border-border
         bg-background text-foreground
         px-3 py-1 text-sm shadow-sm
         transition-colors
         focus-visible:outline-none
         focus-visible:ring-1
         focus-visible:ring-ring">
        <!-- å‡è®¾ EO å¯¹åº”çš„é¡µé¢æ˜¯ eo.htmlï¼ŒESA å¯¹åº”çš„é¡µé¢æ˜¯ esa.html -->
        <option value="index.html">è…¾è®¯äº‘ EO ç›‘æ§</option>
        <option value="aliesa.html" selected>é˜¿é‡Œäº‘ ESA ç›‘æ§</option>
		<option value="cloudflare.html">Cloudflare ç›‘æ§</option>
		</select>
		</div>
            <!-- <button onclick="refreshData()" class="h-9 px-4 py-2 bg-slate-900 text-white hover:bg-slate-900/90 inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-slate-950 shadow">
                åˆ·æ–°
            </button> -->
        </div>

        <!-- Main Content -->
        <div class="space-y-8">

            <!-- Section 1: Traffic (æµé‡) -->
            <div class="space-y-4">
                <h2 class="text-xl font-bold tracking-tight text-foreground flex items-center gap-2">
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                    æµé‡åˆ†æ (Traffic)
                </h2>
                <div class="grid gap-4 md:grid-cols-3 lg:grid-cols-4">
                    <!-- Total Traffic Card -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="p-6 flex flex-row items-center justify-between space-y-0 pb-2">
                            <h3 class="tracking-tight text-sm font-medium text-muted-foreground">æ€»æµé‡ (Total)</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div class="text-2xl font-bold" id="kpi_l7Flow_flux">åŠ è½½ä¸­...</div>
                            <p class="text-xs text-muted-foreground mt-1">è®¿é—®æ€»æµé‡</p>
                        </div>
                    </div>
                    <!-- Client Request Traffic -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="p-6 flex flex-row items-center justify-between space-y-0 pb-2">
                            <h3 class="tracking-tight text-sm font-medium text-muted-foreground">å®¢æˆ·ç«¯è¯·æ±‚æµé‡ (In)</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div class="text-2xl font-bold" id="kpi_l7Flow_inFlux">åŠ è½½ä¸­...</div>
                            <p class="text-xs text-muted-foreground mt-1">å®¢æˆ·ç«¯è¯·æ±‚æµé‡</p>
                        </div>
                    </div>
                    <!-- EdgeOne Response Traffic -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="p-6 flex flex-row items-center justify-between space-y-0 pb-2">
                            <h3 class="tracking-tight text-sm font-medium text-muted-foreground">å“åº”æµé‡ (Out)</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div class="text-2xl font-bold" id="kpi_l7Flow_outFlux">åŠ è½½ä¸­...</div>
                            <p class="text-xs text-muted-foreground mt-1">ESA å“åº”æµé‡</p>
                        </div>
                    </div>
					<div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="p-6 flex flex-row items-center justify-between space-y-0 pb-2">
                            <h3 class="tracking-tight text-sm font-medium text-muted-foreground">æ€»è¯·æ±‚æ•°</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div class="text-2xl font-bold" id="kpi_l7Flow_request">åŠ è½½ä¸­...</div>
                            <p class="text-xs text-muted-foreground mt-1">æ€»è¯·æ±‚æ¬¡æ•°</p>
                        </div>
                    </div>
                </div>
				<div class="grid gap-4 md:grid-cols-2 lg:grid-cols-2">
                <!-- Traffic Chart -->
                <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                    <div class="flex flex-col space-y-1.5 p-6">
                        <h3 class="font-semibold leading-none tracking-tight">æµé‡è¶‹åŠ¿</h3>
                    </div>
                    <div class="p-6 pt-0">
                        <div id="chart_traffic" class="w-full h-[350px]"></div>
                    </div>
                </div>
				<div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                    <div class="flex flex-col space-y-1.5 p-6">
                        <h3 class="font-semibold leading-none tracking-tight">è¯·æ±‚è¶‹åŠ¿</h3>
                    </div>
                    <div class="p-6 pt-0">
                        <div id="chart_requests" class="w-full h-[350px]"></div>
                    </div>
                </div>
				</div>
            </div>
            <!-- Section 6: Top Analysis (TOP åˆ†æ) -->
            <div class="space-y-4">
                <h2 class="text-xl font-bold tracking-tight text-foreground flex items-center gap-2">
                    <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                    TOP åˆ†æ (Top Analysis)
                </h2>
                <!-- World Map -->
                <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                    <div class="flex flex-col space-y-1.5 p-6">
                        <h3 class="font-semibold leading-none tracking-tight">å…¨çƒè¯·æ±‚åˆ†å¸ƒ</h3>
                    </div>
                    <div class="p-6 pt-0">
                        <div id="chart_top_map" class="w-full h-[500px]"></div>
                    </div>
                </div>
				
                <div class="grid gap-4 md:grid-cols-2">
					<!-- Country -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å›½å®¶/åœ°åŒºæµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_country" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å›½å®¶/åœ°åŒºè¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_country" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- Province -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å›½å†…çœä»½æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_province" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å›½å†…çœä»½è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_province" class="w-full h-[500px]"></div>
                        </div>
                    </div>
					<!-- Device Type -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">è¯·æ±‚æ–¹æ³•æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_ua_device" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">è¯·æ±‚æ–¹æ³•æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_ua_device" class="w-full h-[500px]"></div>
                        </div>
                    </div>
					<div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">ç¼“å­˜çŠ¶æ€æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_ua_browser" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">ç¼“å­˜çŠ¶æ€è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_ua_browser" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <!-- Status Code -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">çŠ¶æ€ç æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_status_code" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">çŠ¶æ€ç è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_status_code" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- Domain -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">åŸŸåæµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_domain" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">åŸŸåè¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_domain" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- URL -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">URL æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_url" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">URL è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_url" class="w-full h-[500px]"></div>
                        </div>
                    </div>
					
					<!-- ?URL -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">URL æŸ¥è¯¢æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_url_query" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">URL æŸ¥è¯¢è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_url_query" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- Resource Type -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">èµ„æºç±»å‹æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_resource_type" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">èµ„æºç±»å‹è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_resource_type" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- Client IP -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å®¢æˆ·ç«¯IPæµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_sip" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">å®¢æˆ·ç«¯IPè¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_sip" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- Referer -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">Referer æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_referer" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">Referer è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_referer" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- OS -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">æ“ä½œç³»ç»Ÿæµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_ua_os" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">æ“ä½œç³»ç»Ÿè¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_ua_os" class="w-full h-[500px]"></div>
                        </div>
                    </div>

                    <!-- User Agent -->
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">User Agent æµé‡æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_ua" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                    <div class="rounded-xl border bg-card text-card-foreground shadow-sm">
                        <div class="flex flex-col space-y-1.5 p-6">
                            <h3 class="font-semibold leading-none tracking-tight">User Agent è¯·æ±‚æ•°æ’è¡Œ</h3>
                        </div>
                        <div class="p-6 pt-0">
                            <div id="chart_top_request_ua" class="w-full h-[500px]"></div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        // ECharts instance variables
		let currentAbortController = null; // ç”¨äºæ§åˆ¶è¯·æ±‚å–æ¶ˆ
        let chartTraffic = null;
        let chartRequests = null;
        let chartPerformance = null;
        let chartSecurity = null;
        let chartTopCountry = null;
        let chartTopProvince = null;
        let chartTopStatusCode = null;
        let chartTopDomain = null;
        let chartTopUrl = null;
        let chartTopResourceType = null;
		
        let chartTopUrlquery = null;
        let chartTopResourceTypequery = null;
		
        let chartTopSip = null;
        let chartTopReferer = null;
        let chartTopUaDevice = null;
        let chartTopUaBrowser = null;
        let chartTopUaOs = null;
        let chartTopUa = null;
        let chartTopRequestCountry = null;
        let chartTopRequestProvince = null;
        let chartTopRequestStatusCode = null;
        let chartTopRequestDomain = null;
        let chartTopRequestUrl = null;
        let chartTopRequestResourceType = null;
        let chartTopRequestSip = null;
        let chartTopRequestReferer = null;
        let chartTopRequestUaDevice = null;
        let chartTopRequestUaBrowser = null;
        let chartTopRequestUaOs = null;
        let chartTopRequestUa = null;
        let chartTopMap = null;
        let chartFunctionRequests = null;
        let chartFunctionCpu = null;

        let lastResults = null; // Global variable to store last fetched data for theme switching

        const provinceMap = {
            'Beijing': 'åŒ—äº¬', 'Neimenggu': 'å†…è’™å¤', 'Shanxi': 'å±±è¥¿', 'Hebei': 'æ²³åŒ—', 'Tianjin': 'å¤©æ´¥',
            'Ningxia': 'å®å¤', 'Shaanxi': 'é™•è¥¿', 'Gansu': 'ç”˜è‚ƒ', 'Xinjiang': 'é’æµ·', '1468': 'æ–°ç–†',
            'Heilongjiang': 'é»‘é¾™æ±Ÿ', 'Jilin': 'å‰æ—', 'Liaoning': 'è¾½å®', 'Fujian': 'ç¦å»º', 'Jiangsu': 'æ±Ÿè‹',
            'Anhui': 'å®‰å¾½', 'Shandong': 'å±±ä¸œ', 'Shanghai': 'ä¸Šæµ·', 'Zhejiang': 'æµ™æ±Ÿ', 'Henan': 'æ²³å—',
            'Hubei': 'æ¹–åŒ—', 'Jiangxi': 'æ±Ÿè¥¿', 'Hunan': 'æ¹–å—', 'Guizhou': 'è´µå·', 'Yunnan': 'äº‘å—',
            'Chongqing': 'é‡åº†', 'Sichuan': 'å››å·', 'Xizang': 'è¥¿è—', 'Guangdong': 'å¹¿ä¸œ', 'Guangxi': 'å¹¿è¥¿','Qinghai':'é’æµ·',
            'Hainan': 'æµ·å—', '0': 'å…¶ä»–', '1': 'æ¸¯æ¾³å°', '-': 'ä¸­å›½å†…åœ°'
        };

        const countryMap = {
            'CN': 'ä¸­å›½å¤§é™†', 'AF': 'é˜¿å¯Œæ±—', 'MV': 'é©¬å°”ä»£å¤«', 'AM': 'äºšç¾å°¼äºš', 'MN': 'è’™å¤', 'AZ': 'é˜¿å¡æ‹œç–†',
            'MM': 'ç¼…ç”¸', 'BH': 'å·´æ—', 'NP': 'å°¼æ³Šå°”', 'BD': 'å­ŸåŠ æ‹‰', 'KP': 'æœé²œ',
            'BT': 'ä¸ä¸¹', 'OM': 'é˜¿æ›¼', 'IO': 'è‹±å±å°åº¦æ´‹é¢†åœ°', 'PK': 'å·´åŸºæ–¯å¦', 'KH': 'æŸ¬åŸ”å¯¨',
            'PS': 'å·´å‹’æ–¯å¦', 'CX': 'åœ£è¯å²›', 'PH': 'è²å¾‹å®¾', 'HK': 'ä¸­å›½é¦™æ¸¯', 'QA': 'å¡å¡”å°”',
            'IN': 'å°åº¦', 'SA': 'æ²™ç‰¹é˜¿æ‹‰ä¼¯', 'ID': 'å°åº¦å°¼è¥¿äºš', 'SG': 'æ–°åŠ å¡', 'IR': 'ä¼Šæœ—',
            'KR': 'éŸ©å›½', 'IQ': 'ä¼Šæ‹‰å…‹', 'LK': 'æ–¯é‡Œå…°å¡', 'IL': 'ä»¥è‰²åˆ—', 'SY': 'å™åˆ©äºš',
            'JP': 'æ—¥æœ¬', 'TW': 'ä¸­å›½å°æ¹¾', 'JO': 'çº¦æ—¦', 'TJ': 'å¡”å‰å…‹æ–¯å¦', 'KZ': 'å“ˆè¨å…‹æ–¯å¦',
            'TH': 'æ³°å›½', 'KW': 'ç§‘å¨ç‰¹', 'TM': 'åœŸåº“æ›¼æ–¯å¦', 'KG': 'å‰å°”å‰æ–¯æ–¯å¦', 'AE': 'é˜¿è”é…‹',
            'LA': 'è€æŒ', 'UZ': 'ä¹Œå…¹åˆ«å…‹æ–¯å¦', 'LB': 'é»å·´å«©', 'VN': 'è¶Šå—', 'MO': 'ä¸­å›½æ¾³é—¨',
            'YE': 'ä¹Ÿé—¨', 'MY': 'é©¬æ¥è¥¿äºš', 'TR': 'åœŸè€³å…¶', 'AX': 'å¥¥å…°ç¾¤å²›', 'IT': 'æ„å¤§åˆ©',
            'AL': 'é˜¿å°”å·´å°¼äºš', 'JE': 'æ³½è¥¿å²›', 'AD': 'å®‰é“å°”', 'LT': 'ç«‹é™¶å®›', 'AT': 'å¥¥åœ°åˆ©',
            'LU': 'å¢æ£®å ¡', 'BY': 'ç™½ä¿„ç½—æ–¯', 'MK': 'é©¬å…¶é¡¿', 'BE': 'æ¯”åˆ©æ—¶', 'MT': 'é©¬è€³ä»–',
            'BA': 'æ³¢é»‘', 'MD': 'æ‘©å°”å¤šç“¦', 'BG': 'ä¿åŠ åˆ©äºš', 'MC': 'æ‘©çº³å“¥', 'BQ': 'è·å…°åŠ å‹’æ¯”åŒº',
            'ME': 'é»‘å±±', 'HR': 'å…‹ç½—åœ°äºš', 'NL': 'è·å…°', 'CZ': 'æ·å…‹', 'NO': 'æŒªå¨',
            'DK': 'ä¸¹éº¦', 'PL': 'æ³¢å…°', 'EE': 'çˆ±æ²™å°¼äºš', 'PT': 'è‘¡è„ç‰™', 'FO': 'æ³•ç½—ç¾¤å²›',
            'RO': 'ç½—é©¬å°¼äºš', 'FI': 'èŠ¬å…°', 'RU': 'ä¿„ç½—æ–¯', 'FR': 'æ³•å›½', 'SM': 'åœ£é©¬åŠ›è¯º',
            'DE': 'å¾·å›½', 'RS': 'å¡å°”ç»´äºš', 'GI': 'ç›´å¸ƒç½—é™€', 'SX': 'è·å±åœ£é©¬ä¸', 'GR': 'å¸Œè…Š',
            'SK': 'æ–¯æ´›ä¼å…‹', 'GG': 'æ ¹è¥¿å²›', 'ES': 'è¥¿ç­ç‰™', 'HU': 'åŒˆç‰™åˆ©', 'SE': 'ç‘å…¸',
            'IS': 'å†°å²›', 'CH': 'ç‘å£«', 'IE': 'çˆ±å°”å…°', 'UA': 'ä¹Œå…‹å…°', 'IM': 'é©¬æ©å²›',
            'GB': 'è‹±å›½', 'DZ': 'é˜¿å°”åŠåˆ©äºš', 'ML': 'é©¬é‡Œ', 'AO': 'å®‰å“¥æ‹‰', 'MR': 'æ¯›é‡Œå¡”å°¼äºš',
            'BJ': 'è´å®', 'MU': 'æ¯›é‡Œæ±‚æ–¯', 'BW': 'åšèŒ¨ç“¦çº³', 'YT': 'é©¬çº¦ç‰¹', 'BF': 'å¸ƒåŸºçº³æ³•ç´¢',
            'MA': 'æ‘©æ´›å“¥', 'BI': 'å¸ƒéš†è¿ª', 'MZ': 'è«æ¡‘æ¯”å…‹', 'CM': 'å–€éº¦éš†', 'NA': 'çº³ç±³æ¯”äºš',
            'CV': 'ä½›å¾—è§’', 'NE': 'å°¼æ—¥å°”', 'CF': 'ä¸­é', 'NG': 'å°¼æ—¥åˆ©äºš', 'TD': 'ä¹å¾—',
            'RW': 'å¢æ—ºè¾¾', 'KM': 'ç§‘æ‘©ç½—', 'SH': 'åœ£èµ«å‹’æ‹¿', 'DJ': 'å‰å¸ƒæ', 'ST': 'åœ£å¤šç¾å’Œæ™®æ—è¥¿æ¯”',
            'EG': 'åŸƒåŠ', 'SN': 'å¡å†…åŠ å°”', 'GQ': 'èµ¤é“å‡ å†…äºš', 'SC': 'å¡èˆŒå°”', 'ER': 'å„ç«‹ç‰¹é‡Œäºš',
            'SL': 'å¡æ‹‰åˆ©æ˜‚', 'ET': 'åŸƒå¡ä¿„æ¯”äºš', 'SO': 'ç´¢é©¬é‡Œ', 'GA': 'åŠ è“¬', 'ZA': 'å—é',
            'GM': 'å†ˆæ¯”äºš', 'SS': 'å—è‹ä¸¹', 'GH': 'åŠ çº³', 'SD': 'è‹ä¸¹', 'GN': 'å‡ å†…äºš',
            'SZ': 'æ–¯å¨å£«å…°', 'GW': 'å‡ å†…äºšæ¯”ç»', 'TZ': 'å¦æ¡‘å°¼äºš', 'KE': 'è‚¯å°¼äºš', 'TG': 'å¤šå“¥',
            'LS': 'è±ç´¢æ‰˜', 'TN': 'çªå°¼æ–¯', 'LR': 'åˆ©æ¯”é‡Œäºš', 'UG': 'ä¹Œå¹²è¾¾', 'LY': 'åˆ©æ¯”äºš',
            'EH': 'è¥¿æ’’å“ˆæ‹‰', 'MG': 'é©¬è¾¾åŠ æ–¯åŠ ', 'ZM': 'èµæ¯”äºš', 'MW': 'é©¬æ‹‰ç»´', 'ZW': 'æ´¥å·´å¸ƒéŸ¦',
            'CD': 'åˆšæœæ°‘ä¸»å…±å’Œå›½', 'CG': 'åˆšæœå…±å’Œå›½', 'CI': 'ç§‘ç‰¹è¿ªç“¦', 'AU': 'æ¾³å¤§åˆ©äºš', 'NF': 'è¯ºç¦å…‹å²›',
            'CK': 'åº“å…‹ç¾¤å²›', 'MP': 'åŒ—é©¬é‡Œäºšçº³ç¾¤å²›', 'TL': 'ä¸œå¸æ±¶', 'PW': 'å¸•åŠ³', 'GU': 'å…³å²›',
            'PG': 'å·´å¸ƒäºšæ–°å‡ å†…äºš', 'KI': 'åŸºé‡Œå·´æ–¯', 'SB': 'æ‰€ç½—é—¨ç¾¤å²›', 'MH': 'é©¬ç»å°”ç¾¤å²›', 'TO': 'æ±¤åŠ ',
            'NR': 'ç‘™é²', 'TV': 'å›¾ç“¦å¢', 'NZ': 'æ–°è¥¿å…°', 'AI': 'å®‰åœ­æ‹‰', 'HT': 'æµ·åœ°',
            'AG': 'å®‰æç“œå’Œå·´å¸ƒè¾¾', 'HN': 'æ´ªéƒ½æ‹‰æ–¯', 'AW': 'é˜¿é²å·´', 'JM': 'ç‰™ä¹°åŠ ', 'BS': 'å·´å“ˆé©¬',
            'MX': 'å¢¨è¥¿å“¥', 'BB': 'å·´å·´å¤šæ–¯', 'MS': 'è’™å¡æ‹‰ç‰¹å²›', 'BM': 'ç™¾æ…•å¤§', 'NI': 'å°¼åŠ æ‹‰ç“œ',
            'CA': 'åŠ æ‹¿å¤§', 'PA': 'å·´æ‹¿é©¬', 'KY': 'å¼€æ›¼ç¾¤å²›', 'PR': 'æ³¢å¤šé»å„', 'CR': 'å“¥æ–¯è¾¾é»åŠ ',
            'KN': 'åœ£åŸºèŒ¨å’Œå°¼ç»´æ–¯', 'CU': 'å¤å·´', 'LC': 'åœ£å¢è¥¿äºš', 'CW': 'åº“æ‹‰ç´¢', 'MF': 'æ³•å±åœ£é©¬ä¸',
            'SV': 'è¨å°”ç“¦å¤š', 'TT': 'ç‰¹ç«‹å°¼è¾¾å’Œå¤šå·´å“¥', 'GL': 'æ ¼é™µå…°å²›', 'TC': 'ç‰¹å…‹æ–¯å’Œå‡¯ç§‘æ–¯ç¾¤å²›',
            'GD': 'æ ¼æ—çº³è¾¾', 'US': 'ç¾å›½', 'GT': 'å±åœ°é©¬æ‹‰', 'AR': 'é˜¿æ ¹å»·', 'GY': 'åœ­äºšé‚£',
            'BO': 'ç»åˆ©ç»´äºš', 'PY': 'å·´æ‹‰åœ­', 'BR': 'å·´è¥¿', 'PE': 'ç§˜é²', 'CL': 'æ™ºåˆ©',
            'SR': 'è‹é‡Œå—', 'CO': 'å“¥ä¼¦æ¯”äºš', 'UY': 'ä¹Œæ‹‰åœ­', 'EC': 'å„ç“œå¤šå°”', 'VE': 'å§”å†…ç‘æ‹‰',
            'GF': 'æ³•å±åœ­äºšé‚£', 'Antarctica': 'å—ææ´²'
        };

        const codeToMapName = {
            'CN': 'China', 'AF': 'Afghanistan', 'AL': 'Albania', 'DZ': 'Algeria', 'AO': 'Angola', 'AR': 'Argentina',
            'AM': 'Armenia', 'AU': 'Australia', 'AT': 'Austria', 'AZ': 'Azerbaijan', 'BS': 'Bahamas', 'BH': 'Bahrain',
            'BD': 'Bangladesh', 'BB': 'Barbados', 'BY': 'Belarus', 'BE': 'Belgium', 'BZ': 'Belize', 'BJ': 'Benin',
            'BT': 'Bhutan', 'BO': 'Bolivia', 'BA': 'Bosnia and Herzegovina', 'BW': 'Botswana', 'BR': 'Brazil',
            'BN': 'Brunei', 'BG': 'Bulgaria', 'BF': 'Burkina Faso', 'BI': 'Burundi', 'KH': 'Cambodia', 'CM': 'Cameroon',
            'CA': 'Canada', 'CF': 'Central African Republic', 'TD': 'Chad', 'CL': 'Chile', 'CO': 'Colombia',
            'KM': 'Comoros', 'CG': 'Republic of the Congo', 'CD': 'Democratic Republic of the Congo', 'CR': 'Costa Rica',
            'HR': 'Croatia', 'CU': 'Cuba', 'CY': 'Cyprus', 'CZ': 'Czech Republic', 'DK': 'Denmark', 'DJ': 'Djibouti',
            'DO': 'Dominican Republic', 'EC': 'Ecuador', 'EG': 'Egypt', 'SV': 'El Salvador', 'GQ': 'Equatorial Guinea',
            'ER': 'Eritrea', 'EE': 'Estonia', 'ET': 'Ethiopia', 'FJ': 'Fiji', 'FI': 'Finland', 'FR': 'France',
            'GA': 'Gabon', 'GM': 'Gambia', 'GE': 'Georgia', 'DE': 'Germany', 'GH': 'Ghana', 'GR': 'Greece',
            'GT': 'Guatemala', 'GN': 'Guinea', 'GW': 'Guinea-Bissau', 'GY': 'Guyana', 'HT': 'Haiti', 'HN': 'Honduras',
            'HU': 'Hungary', 'IS': 'Iceland', 'IN': 'India', 'ID': 'Indonesia', 'IR': 'Iran', 'IQ': 'Iraq',
            'IE': 'Ireland', 'IL': 'Israel', 'IT': 'Italy', 'CI': 'Ivory Coast', 'JM': 'Jamaica', 'JP': 'Japan',
            'JO': 'Jordan', 'KZ': 'Kazakhstan', 'KE': 'Kenya', 'KP': 'North Korea', 'KR': 'South Korea',
            'KW': 'Kuwait', 'KG': 'Kyrgyzstan', 'LA': 'Laos', 'LV': 'Latvia', 'LB': 'Lebanon', 'LS': 'Lesotho',
            'LR': 'Liberia', 'LY': 'Libya', 'LT': 'Lithuania', 'LU': 'Luxembourg', 'MK': 'Macedonia', 'MG': 'Madagascar',
            'MW': 'Malawi', 'MY': 'Malaysia', 'ML': 'Mali', 'MT': 'Malta', 'MR': 'Mauritania', 'MU': 'Mauritius',
            'MX': 'Mexico', 'MD': 'Moldova', 'MN': 'Mongolia', 'ME': 'Montenegro', 'MA': 'Morocco', 'MZ': 'Mozambique',
            'MM': 'Myanmar', 'NA': 'Namibia', 'NP': 'Nepal', 'NL': 'Netherlands', 'NZ': 'New Zealand', 'NI': 'Nicaragua',
            'NE': 'Niger', 'NG': 'Nigeria', 'NO': 'Norway', 'OM': 'Oman', 'PK': 'Pakistan', 'PA': 'Panama',
            'PG': 'Papua New Guinea', 'PY': 'Paraguay', 'PE': 'Peru', 'PH': 'Philippines', 'PL': 'Poland',
            'PT': 'Portugal', 'PR': 'Puerto Rico', 'QA': 'Qatar', 'RO': 'Romania', 'RU': 'Russia', 'RW': 'Rwanda',
            'SA': 'Saudi Arabia', 'SN': 'Senegal', 'RS': 'Serbia', 'SL': 'Sierra Leone', 'SG': 'Singapore',
            'SK': 'Slovakia', 'SI': 'Slovenia', 'SB': 'Solomon Islands', 'SO': 'Somalia', 'ZA': 'South Africa',
            'SS': 'South Sudan', 'ES': 'Spain', 'LK': 'Sri Lanka', 'SD': 'Sudan', 'SR': 'Suriname', 'SZ': 'Swaziland',
            'SE': 'Sweden', 'CH': 'Switzerland', 'SY': 'Syria', 'TW': 'Taiwan', 'TJ': 'Tajikistan', 'TZ': 'Tanzania',
            'TH': 'Thailand', 'TL': 'Timor-Leste', 'TG': 'Togo', 'TT': 'Trinidad and Tobago', 'TN': 'Tunisia',
            'TR': 'Turkey', 'TM': 'Turkmenistan', 'UG': 'Uganda', 'UA': 'Ukraine', 'AE': 'United Arab Emirates',
            'GB': 'United Kingdom', 'US': 'United States', 'UY': 'Uruguay', 'UZ': 'Uzbekistan', 'VU': 'Vanuatu',
            'VE': 'Venezuela', 'VN': 'Vietnam', 'GL': 'Greenland','YE': 'Yemen', 'ZM': 'Zambia', 'ZW': 'Zimbabwe'
        };

        const worldNameMap = {};
        Object.keys(codeToMapName).forEach(code => {
            if (countryMap[code]) {
                worldNameMap[codeToMapName[code]] = countryMap[code];
            }
        });

        const metricsConfig = {
            traffic: ['l7Flow_flux', 'l7Flow_inFlux', 'l7Flow_outFlux'],
            bandwidth: [],
            originPull: [],
            requests: ['l7Flow_request'],
            performance: [],
            edgeFunctions: [],
            security: [],
            topAnalysis: ['l7Flow_request_country','l7Flow_outFlux_country','l7Flow_outFlux_province','l7Flow_request_province','l7Flow_outFlux_ua_device','l7Flow_request_ua_device','l7Flow_outFlux_ua_browser','l7Flow_request_ua_browser','l7Flow_outFlux_statusCode','l7Flow_request_statusCode','l7Flow_outFlux_domain','l7Flow_request_domain','l7Flow_outFlux_url','l7Flow_request_url','l7Flow_outFlux_urlquery','l7Flow_url_res_query','l7Flow_outFlux_resourceType', 'l7Flow_request_resourceType','l7Flow_outFlux_sip','l7Flow_request_sip','l7Flow_outFlux_referers','l7Flow_request_referers','l7Flow_outFlux_ua_os','l7Flow_request_ua_os','l7Flow_outFlux_ua','l7Flow_request_ua']
        };

        const metricLabels = {
            'l7Flow_flux': 'æ€»æµé‡',
            'l7Flow_inFlux': 'å®¢æˆ·ç«¯è¯·æ±‚æµé‡',
            'l7Flow_outFlux': 'å“åº”æµé‡',
            'l7Flow_bandwidth': 'æ€»å¸¦å®½',
            'l7Flow_inBandwidth': 'è¯·æ±‚å¸¦å®½',
            'l7Flow_outBandwidth': 'å“åº”å¸¦å®½',
            'l7Flow_outFlux_hy': 'å›æºè¯·æ±‚æµé‡',
            'l7Flow_inFlux_hy': 'å›æºå“åº”æµé‡',
            'l7Flow_outBandwidth_hy': 'å›æºè¯·æ±‚å¸¦å®½',
            'l7Flow_inBandwidth_hy': 'å›æºå“åº”å¸¦å®½',
            'l7Flow_request_hy': 'å›æºè¯·æ±‚æ•°',
            'l7Flow_request': 'è¯·æ±‚æ•°',
            'l7Flow_avgResponseTime': 'å¹³å‡å“åº”è€—æ—¶',
            'l7Flow_avgFirstByteResponseTime': 'å¹³å‡é¦–å­—èŠ‚è€—æ—¶',
            'function_requestCount': 'Edge Functions è¯·æ±‚æ•°',
            'function_cpuCostTime': 'Edge Functions CPU æ—¶é—´',
            'ccAcl_interceptNum': 'ç²¾ç¡®é˜²æŠ¤æ‹¦æˆª',
            'ccManage_interceptNum': 'æ‰˜ç®¡è§„åˆ™æ‹¦æˆª',
            'ccRate_interceptNum': 'é€Ÿç‡é™åˆ¶æ‹¦æˆª',
            'l7Flow_outFlux_country': 'å›½å®¶/åœ°åŒºæµé‡',
            'l7Flow_outFlux_province': 'å›½å†…çœä»½æµé‡',
            'l7Flow_outFlux_statusCode': 'çŠ¶æ€ç æµé‡',
            'l7Flow_outFlux_domain': 'åŸŸåæµé‡',
            'l7Flow_outFlux_url': 'URL æµé‡',			
			'l7Flow_outFlux_urlquery': 'URL æŸ¥è¯¢æµé‡',
			'l7Flow_url_res_query': 'URL æŸ¥è¯¢è¯·æ±‚æ•°',			
            'l7Flow_outFlux_resourceType': 'èµ„æºç±»å‹æµé‡',
            'l7Flow_outFlux_sip': 'å®¢æˆ·ç«¯IPæµé‡',
            'l7Flow_outFlux_referers': 'Referer æµé‡',
            'l7Flow_outFlux_ua_device': 'è¯·æ±‚æ–¹æ³•æµé‡',
            'l7Flow_outFlux_ua_browser': 'ç¼“å­˜çŠ¶æ€æµé‡',
            'l7Flow_outFlux_ua_os': 'æ“ä½œç³»ç»Ÿæµé‡',
            'l7Flow_outFlux_ua': 'User Agent æµé‡',
            'l7Flow_request_country': 'å›½å®¶/åœ°åŒºè¯·æ±‚æ•°',
            'l7Flow_request_province': 'å›½å†…çœä»½è¯·æ±‚æ•°',
            'l7Flow_request_statusCode': 'çŠ¶æ€ç è¯·æ±‚æ•°',
            'l7Flow_request_domain': 'åŸŸåè¯·æ±‚æ•°',
            'l7Flow_request_url': 'URL è¯·æ±‚æ•°',
            'l7Flow_request_resourceType': 'èµ„æºç±»å‹è¯·æ±‚æ•°',
            'l7Flow_request_sip': 'å®¢æˆ·ç«¯IPè¯·æ±‚æ•°',
            'l7Flow_request_referers': 'Referer è¯·æ±‚æ•°',
            'l7Flow_request_ua_device': 'è¯·æ±‚æ–¹æ³•è¯·æ±‚æ•°',
            'l7Flow_request_ua_browser': 'ç¼“å­˜çŠ¶æ€è¯·æ±‚æ•°',
            'l7Flow_request_ua_os': 'æ“ä½œç³»ç»Ÿè¯·æ±‚æ•°',
            'l7Flow_request_ua': 'User Agent è¯·æ±‚æ•°'
        };

        const metricColors = {
            'l7Flow_flux': '#3b82f6', // blue
            'l7Flow_inFlux': '#f59e0b', // amber
            'l7Flow_outFlux': '#10b981', // green
            'l7Flow_bandwidth': '#8b5cf6', // purple
            'l7Flow_inBandwidth': '#ec4899', // pink
            'l7Flow_outBandwidth': '#06b6d4', // cyan
            'l7Flow_outFlux_hy': '#3b82f6', // blue
            'l7Flow_inFlux_hy': '#10b981', // green
            'l7Flow_outBandwidth_hy': '#8b5cf6', // purple
            'l7Flow_inBandwidth_hy': '#ec4899', // pink
            'l7Flow_request_hy': '#f43f5e', // rose
            'l7Flow_request': '#f43f5e', // rose
            'l7Flow_avgResponseTime': '#ef4444', // red
            'l7Flow_avgFirstByteResponseTime': '#f97316', // orange
            'function_requestCount': '#8b5cf6', // purple
            'function_cpuCostTime': '#06b6d4', // cyan
            'ccAcl_interceptNum': '#ef4444', // red
            'ccManage_interceptNum': '#f59e0b', // amber
            'ccRate_interceptNum': '#3b82f6', // blue
            'l7Flow_outFlux_country': '#3b82f6', // blue
            'l7Flow_outFlux_province': '#f59e0b', // amber
            'l7Flow_outFlux_statusCode': '#8b5cf6', // purple
            'l7Flow_outFlux_domain': '#06b6d4', // cyan
            'l7Flow_outFlux_url': '#10b981', // green
            'l7Flow_outFlux_resourceType': '#f59e0b', // amber
            'l7Flow_outFlux_sip': '#ef4444', // red
            'l7Flow_outFlux_referers': '#8b5cf6', // purple
            'l7Flow_outFlux_ua_device': '#06b6d4', // cyan
            'l7Flow_outFlux_ua_browser': '#f59e0b', // amber
            'l7Flow_outFlux_ua_os': '#10b981', // green
            'l7Flow_outFlux_ua': '#8b5cf6', // purple
            'l7Flow_request_country': '#3b82f6', // blue
            'l7Flow_request_province': '#f59e0b', // amber
            'l7Flow_request_statusCode': '#8b5cf6', // purple
            'l7Flow_request_domain': '#06b6d4', // cyan
            'l7Flow_request_url': '#10b981', // green
            'l7Flow_request_resourceType': '#f59e0b', // amber
            'l7Flow_request_sip': '#8b5cf6', // purple
            'l7Flow_request_referers': '#ec4899', // pink
            'l7Flow_request_ua_device': '#06b6d4', // cyan
            'l7Flow_request_ua_browser': '#10b981', // green
            'l7Flow_request_ua_os': '#f59e0b', // amber
            'l7Flow_request_ua': '#8b5cf6' // purple
        };

        /** Tool Functions **/

        function formatDate(date) {
            return date.toISOString().slice(0, 19) + 'Z';
        }

        function handleTimeRangeChange() {
            const range = document.getElementById('timeRange').value;
            const customInputs = document.getElementById('customTimeInputs');
            if (range === 'custom') {
                customInputs.classList.remove('hidden');
                customInputs.classList.add('flex');
            } else {
                customInputs.classList.add('hidden');
                customInputs.classList.remove('flex');
                refreshData();
            }
        }

        function calculateTimeRange() {
            const range = document.getElementById('timeRange').value;
            const now = new Date();
            let endTime = new Date(now);
            let startTime;

            switch(range) {
                case '30min': startTime = new Date(now.getTime() - 30 * 60 * 1000); break;
                case '1h': startTime = new Date(now.getTime() - 1 * 60 * 60 * 1000); break;
                case '6h': startTime = new Date(now.getTime() - 6 * 60 * 60 * 1000); break;
                case 'today': 
                    startTime = new Date(now);
                    startTime.setHours(0, 0, 0, 0);
                    break;
                case 'yesterday':
                    startTime = new Date(now);
                    startTime.setDate(now.getDate() - 1);
                    startTime.setHours(0, 0, 0, 0);
                    
                    endTime = new Date(now);
                    endTime.setDate(now.getDate() - 1);
                    endTime.setHours(23, 59, 59, 999);
                    break;
                case '3d': startTime = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000); break;
                case '7d': startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                case '14d': startTime = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000); break;
                case '31d': startTime = new Date(now.getTime() - 31 * 24 * 60 * 60 * 1000); break;
                case 'custom':
                    const days = parseInt(document.getElementById('customDays').value) || 0;
                    const hours = parseInt(document.getElementById('customHours').value) || 0;
                    const minutes = parseInt(document.getElementById('customMinutes').value) || 0;
                    const seconds = parseInt(document.getElementById('customSeconds').value) || 0;
                    
                    let totalMs = ((days * 24 * 60 * 60) + (hours * 60 * 60) + (minutes * 60) + seconds) * 1000;
                    const maxMs = 31 * 24 * 60 * 60 * 1000; // 31 days limit
                    const errorEl = document.getElementById('timeRangeError');

                    if (totalMs > maxMs) {
                        if (errorEl) errorEl.innerText = 'è‡ªå®šä¹‰æ—¶é—´èŒƒå›´ä¸èƒ½è¶…è¿‡ 31 å¤©ï¼Œå·²è‡ªåŠ¨ä¸ºæ‚¨è°ƒæ•´ä¸º 31 å¤©ã€‚';
                        totalMs = maxMs;
                    } else {
                        if (errorEl) errorEl.innerText = '';
                    }

                    if (totalMs > 0) {
                        startTime = new Date(now.getTime() - totalMs);
                    } else {
                        // Default to 1 hour if nothing entered
                        startTime = new Date(now.getTime() - 60 * 60 * 1000);
                    }
                    break;
                default: startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }

            return {
                startTime: formatDate(startTime),
                endTime: formatDate(endTime)
            };
        }

        function calculatePreviousRange(startStr, endStr) {
            const start = new Date(startStr);
            const end = new Date(endStr);
            const duration = end.getTime() - start.getTime();
            const prevEnd = new Date(start.getTime()); 
            const prevStart = new Date(prevEnd.getTime() - duration);
            return {
                prevStartTime: formatDate(prevStart),
                prevEndTime: formatDate(prevEnd)
            };
        }

        function renderGrowth(elementId, currentVal, prevVal, inverse = false) {
            const el = document.getElementById(elementId);
            if (!el) return;

            let growthEl = document.getElementById(elementId + '_growth');
            if (!growthEl) {
                growthEl = document.createElement('span');
                growthEl.id = elementId + '_growth';
                el.appendChild(growthEl);
            }

            if (prevVal === 0) {
                growthEl.innerText = ''; 
                return;
            }

            const growth = ((currentVal - prevVal) / prevVal) * 100;
            const absGrowth = Math.abs(growth).toFixed(2);
            
 
            
            let colorClass = 'text-gray-500';
            let icon = '';
            
            if (growth > 0) {
                icon = 'â†‘';
                colorClass = 'text-red-500';
            } else if (growth < 0) {
                icon = 'â†“';
                colorClass = 'text-green-500';
            } else {
                icon = '-';
            }

            growthEl.className = `text-sm font-normal ml-2 ${colorClass}`;
            growthEl.innerText = `${icon} ${absGrowth}%`;
        }

      async function fetchData(metric, customStart, customEnd, signal) { // å¢åŠ  signal å‚æ•°
    try {
        let startTime, endTime;
        if (customStart && customEnd) {
            startTime = customStart;
            endTime = customEnd;
        } else {
            const range = calculateTimeRange();
            startTime = range.startTime;
            endTime = range.endTime;
        }

        const interval = document.getElementById('interval').value;
        const zoneId = '';
        
        let url = `/esa/traffic?metric=${metric}&startTime=${encodeURIComponent(startTime)}&endTime=${encodeURIComponent(endTime)}`;
        if (interval && interval !== 'auto') {
            url += `&interval=${interval}`;
        }
        
        // å°† signal ä¼ å…¥ fetch
        const response = await fetch(url, { signal }); 
        const result = await response.json();
        if (result.error) throw new Error(result.error);
        return result;
    } catch (err) {
        // å¦‚æœæ˜¯ä¸»åŠ¨å–æ¶ˆçš„ï¼Œä¸æ‰“å°é”™è¯¯æ—¥å¿—
        if (err.name === 'AbortError') {
            console.log(`Fetch aborted for metric: ${metric}`);
            return null;
        }
        console.error(`Error fetching ${metric}:`, err);
        return null;
    }
}

        function processData(result, targetMetric) {
            // Check for Top Data Structure (DescribeTopL7AnalysisData)
            // It returns Data[0].DetailData (Array of Key/Value)
            if (result?.Data?.[0]?.DetailData) {
                 return {
                     type: 'top',
                     data: result.Data[0].DetailData
                 };
            }

            // DescribeTimingL7AnalysisData returns 'Data'
            // DescribeTimingL7OriginPullData returns 'TimingDataRecords'
            const dataList = result?.Data || result?.TimingDataRecords || [];
            if (dataList.length === 0) return { timeData: [], valueData: [], sum: 0, max: 0, avg: 0, type: 'time' };

            let typeValue;
            
            // Try to find matching metric in TypeValue or Value
            if (targetMetric) {
                if (dataList[0]?.TypeValue) {
                    typeValue = dataList[0].TypeValue.find(item => item.MetricName === targetMetric);
                } else if (dataList[0]?.Value) {
                    typeValue = dataList[0].Value.find(item => item.MetricName === targetMetric);
                }
            }

            // Fallback if not found or no targetMetric (or if only one exists)
            if (!typeValue) {
                 typeValue = dataList[0]?.TypeValue?.[0];
                 // Support DescribeWebProtectionData structure (Value instead of TypeValue)
                 if (!typeValue && dataList[0]?.Value?.[0]) {
                    typeValue = dataList[0].Value[0];
                 }
            }

            const details = typeValue?.Detail || [];
            const sum = typeValue?.Sum || 0;
            const max = typeValue?.Max || 0;
            const avg = typeValue?.Avg || 0;

            const timeData = [];
            const valueData = [];

            // Context for formatting
            const range = document.getElementById('timeRange')?.value || '30min';
            const interval = document.getElementById('interval')?.value || 'auto';
            const longRanges = ['3d', '7d', '14d', '31d'];
            
            // Auto-detect if interval is effectively 'day'
            let isDayInterval = interval === 'day';
            if (interval === 'auto' && details.length > 1) {
                const diff = details[1].Timestamp - details[0].Timestamp;
                // If interval is >= 23 hours (allow some slack), treat as day
                if (diff >= 82800) isDayInterval = true;
            }
            // If auto and range is 31d/15d, it usually defaults to day
            if (interval === 'auto' && ['14d', '31d'].includes(range)) {
                // Check if we have few points (e.g. < 32 for 31d), likely day
                if (details.length <= 32) isDayInterval = true;
            }

            // Calculate time span of the data
            let span = 0;
            if (details.length > 0) {
                 span = details[details.length - 1].Timestamp - details[0].Timestamp;
            }

            details.forEach(item => {
                const date = new Date(item.Timestamp * 1000);
                let label;

                if (isDayInterval) {
                    // Show YYYY-MM-DD
                    label = `${date.getFullYear()}-${(date.getMonth()+1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
                } else if (span > 86400 || longRanges.includes(range) || (range === 'custom' && span > 86400)) {
                    // Show MM-DD HH:mm for long ranges or custom > 24h
                    label = `${(date.getMonth()+1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                } else {
                    // Show HH:mm for short ranges
                    label = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                }

                timeData.push(label);
                valueData.push(item.Value);
            });

            return { timeData, valueData, sum, max, avg, type: 'time' };
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1000;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            if (i < 0) return bytes + ' B';
            if (i >= sizes.length) return (bytes / Math.pow(k, sizes.length - 1)).toFixed(2) + ' ' + sizes[sizes.length - 1];
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatBps(bps) {
            if (bps === 0) return '0 bps';
            const k = 1000;
            const sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps', 'Pbps', 'Ebps', 'Zbps', 'Ybps'];
            const i = Math.floor(Math.log(bps) / Math.log(k));
            if (i < 0) return bps + ' bps';
            if (i >= sizes.length) return (bps / Math.pow(k, sizes.length - 1)).toFixed(2) + ' ' + sizes[sizes.length - 1];
            return parseFloat((bps / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatCount(num) {
            if (num === 0) return '0';
            if (num < 1000) return num.toString();
            if (num < 10000) return (num / 1000).toFixed(2) + ' åƒ';
            if (num < 100000000) return (num / 10000).toFixed(2) + ' ä¸‡';
            return (num / 100000000).toFixed(2) + ' äº¿';
        }

        function getBestCountUnit(maxValue) {
            if (maxValue < 1000) return { unit: 'æ¬¡', divisor: 1 };
            if (maxValue < 10000) return { unit: 'åƒæ¬¡', divisor: 1000 };
            if (maxValue < 100000000) return { unit: 'ä¸‡æ¬¡', divisor: 10000 };
            return { unit: 'äº¿æ¬¡', divisor: 100000000 };
        }

        function getBestUnit(maxValue, type = 'bytes') {
            const k = 1000;
            const byteUnits = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
            const bitUnits = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps', 'Pbps'];
            const units = type === 'bandwidth' ? bitUnits : byteUnits;

            if (maxValue === 0) return { unit: units[0], divisor: 1 };

            let i = Math.floor(Math.log(maxValue) / Math.log(k));
            if (i < 0) i = 0;
            if (i >= units.length) i = units.length - 1;

            return { unit: units[i], divisor: Math.pow(k, i) };
        }

        /** Feature Functions **/


        ////ENTRANCE////
        async function initDashboard() {
            // Initialize charts
            chartTraffic = echarts.init(document.getElementById('chart_traffic'));
            chartRequests = echarts.init(document.getElementById('chart_requests'));
            chartTopCountry = echarts.init(document.getElementById('chart_top_country'));
            chartTopProvince = echarts.init(document.getElementById('chart_top_province'));
            chartTopStatusCode = echarts.init(document.getElementById('chart_top_status_code'));
            chartTopDomain = echarts.init(document.getElementById('chart_top_domain'));
            chartTopUrl = echarts.init(document.getElementById('chart_top_url'));
            chartTopResourceType = echarts.init(document.getElementById('chart_top_resource_type'));
			
			chartTopUrlquery = echarts.init(document.getElementById('chart_top_url_query'));
            chartTopResourceTypequery = echarts.init(document.getElementById('chart_top_request_url_query'));
			
            chartTopSip = echarts.init(document.getElementById('chart_top_sip'));
            chartTopReferer = echarts.init(document.getElementById('chart_top_referer'));
            chartTopUaOs = echarts.init(document.getElementById('chart_top_ua_os'));
			chartTopUaBrowser = echarts.init(document.getElementById('chart_top_ua_browser'));
			chartTopRequestUaBrowser = echarts.init(document.getElementById('chart_top_request_ua_browser'));
            chartTopUa = echarts.init(document.getElementById('chart_top_ua'));
            chartTopRequestCountry = echarts.init(document.getElementById('chart_top_request_country'));
            chartTopRequestProvince = echarts.init(document.getElementById('chart_top_request_province'));
            chartTopRequestStatusCode = echarts.init(document.getElementById('chart_top_request_status_code'));
            chartTopRequestDomain = echarts.init(document.getElementById('chart_top_request_domain'));
            chartTopRequestUrl = echarts.init(document.getElementById('chart_top_request_url'));
            chartTopRequestResourceType = echarts.init(document.getElementById('chart_top_request_resource_type'));
            chartTopRequestSip = echarts.init(document.getElementById('chart_top_request_sip'));
            chartTopRequestReferer = echarts.init(document.getElementById('chart_top_request_referer'));
            chartTopRequestUaOs = echarts.init(document.getElementById('chart_top_request_ua_os'));
            chartTopRequestUa = echarts.init(document.getElementById('chart_top_request_ua'));
            chartTopMap = echarts.init(document.getElementById('chart_top_map'));
            chartTopUaDevice = echarts.init(document.getElementById('chart_top_ua_device'));
			chartTopRequestUaDevice = echarts.init(document.getElementById('chart_top_request_ua_device'));
            
            await refreshData();
        }


// ç­‰å¾…å‡½æ•°
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
async function refreshData() {
    // === æ–°å¢ï¼šä¸­æ–­ä¹‹å‰çš„è¯·æ±‚ ===
    if (currentAbortController) {
        currentAbortController.abort(); // ç»ˆæ­¢æ‰€æœ‰å…³è”çš„ fetch
    }
    currentAbortController = new AbortController();
    const signal = currentAbortController.signal;
    // =========================

    const rawMetrics = [
        ...metricsConfig.traffic,
        ...metricsConfig.bandwidth,
        ...metricsConfig.originPull,
        ...metricsConfig.requests,
        ...metricsConfig.performance,
        ...metricsConfig.edgeFunctions,
        ...metricsConfig.security,
        ...metricsConfig.topAnalysis
    ];
    const uniqueMetrics = [...new Set(rawMetrics)];

    // åˆå§‹åŒ– UI çŠ¶æ€
    document.querySelectorAll('[id^="kpi_"]').forEach(el => {
        if (!el.id.includes('growth')) el.innerText = 'åŠ è½½ä¸­...';
    });

    const progressBar = document.getElementById('loading-progress-bar');
    if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.classList.remove('bg-red-500');
        progressBar.classList.add('bg-blue-500');
        progressBar.parentElement.classList.remove('opacity-0');
    }

    const { startTime, endTime } = calculateTimeRange();
    const totalTasks = uniqueMetrics.length;
    let completedTasks = 0;
    const results = {};

    const updateMap = {
        'traffic': updateTrafficSection,
        'bandwidth': updateBandwidthSection,
        'originPull': updateOriginPullSection,
        'requests': updateRequestsSection,
        'performance': updatePerformanceSection,
        'edgeFunctions': updateEdgeFunctionsSection,
        'security': updateSecuritySection,
        'topAnalysis': updateTopAnalysisSection
    };

    const getSection = (metric) => {
        for (const [section, metrics] of Object.entries(metricsConfig)) {
            if (metrics.includes(metric)) return section;
        }
        return null;
    };

    for (const metric of uniqueMetrics) {
        // === æ–°å¢ï¼šæ¯æ¬¡å¾ªç¯å¼€å§‹å‰æ£€æŸ¥æ˜¯å¦å·²ä¸­æ–­ ===
        if (signal.aborted) return; 

        try {
            // ä¼ å…¥ signal
            const res = await fetchData(metric, startTime, endTime, signal);
            
            // å†æ¬¡æ£€æŸ¥ï¼Œé˜²æ­¢åœ¨è¯·æ±‚è¿‡ç¨‹ä¸­ç”¨æˆ·åˆ‡æ¢äº†æ—¶é—´
            if (signal.aborted) return;

            if (res) {
                results[metric] = processData(res, metric);
                const section = getSection(metric);
                if (section && updateMap[section]) {
                    updateMap[section](results);
                }
            }
        } catch (error) {
            if (error.name === 'AbortError') return; // å¦‚æœæ˜¯å–æ¶ˆè¯·æ±‚ï¼Œç›´æ¥é€€å‡º
            console.error(`è¯·æ±‚å¤±è´¥: ${metric}`, error);
            if (progressBar) progressBar.classList.add('bg-red-500');
        }

        completedTasks++;
        const percentage = (completedTasks / totalTasks) * 100;
        if (progressBar) progressBar.style.width = `${percentage}%`;

        if (completedTasks < totalTasks) {
            // === æ–°å¢ï¼šè®© sleep ä¹Ÿå¯ä»¥è¢«ä¸­æ–­ (å¯é€‰) ===
            await Promise.race([
                sleep(800),
                new Promise((_, reject) => signal.addEventListener('abort', () => reject(new Error('AbortError'))))
            ]).catch(() => {}); 
            
            if (signal.aborted) return;
        }
    }

    lastResults = results; // Store results for theme switching

    setTimeout(() => {
        if (progressBar && !signal.aborted) progressBar.parentElement.classList.add('opacity-0');
    }, 1000);
}
        //1.æœ‰ä½¿ç”¨
        function updateTrafficSection(results) {
            const metrics = metricsConfig.traffic;
            const series = [];
            let timeData = [];

            // Calculate global max
            let globalMax = 0;
            metrics.forEach(metric => {
                const data = results[metric];
                if (data && data.type === 'time') {
                    const max = Math.max(...data.valueData);
                    if (max > globalMax) globalMax = max;
                }
            });

            const { unit, divisor } = getBestUnit(globalMax, 'bytes');

            metrics.forEach(metric => {
                const data = results[metric];
                if (!data || data.type !== 'time') return;
                
                // Update KPI
                document.getElementById(`kpi_${metric}`).innerText = formatBytes(data.sum);

                // Growth
                const prevData = results[metric + '_prev'];
                if (prevData) {
                    renderGrowth(`kpi_${metric}`, data.sum, prevData.sum);
                }

                if (timeData.length === 0) timeData = data.timeData;

                // Chart Data (Dynamic Unit)
                const valueData = data.valueData.map(v => (v / divisor).toFixed(2));
                
                series.push({
                    name: metricLabels[metric],
                    type: 'line',
                    smooth: true,
                    data: valueData,
                    itemStyle: { color: metricColors[metric] },
                    areaStyle: { opacity: 0.1 },
                    // Store raw data for tooltip
                    rawData: data.valueData
                });
            });

            const option = {
                tooltip: { trigger: 'axis', formatter: (params) => {
                    let res = params[0].axisValue + '<br/>';
                    params.forEach(param => {
                        // Access raw data using dataIndex
                        const seriesIndex = param.seriesIndex;
                        const dataIndex = param.dataIndex;
                        const rawVal = series[seriesIndex].rawData[dataIndex];
                        const formattedVal = formatBytes(rawVal);
                        
                        res += `${param.marker}${param.seriesName}: ${formattedVal}<br/>`;
                    });
                    return res;
                }},
                legend: { 
                  data: metrics.map(m => metricLabels[m]), 
                  bottom: 0,
                  icon: 'circle',
                  formatter: function (name) {
                    const metric = Object.keys(metricLabels).find(k => metricLabels[k] === name);
                    return `{${metric}|${name}}`;
                  },
                  textStyle: {
                    rich: {
                      l7Flow_flux: { color: metricColors.l7Flow_flux, fontWeight: 500 },
                      l7Flow_inFlux: { color: metricColors.l7Flow_inFlux, fontWeight: 500 },
                      l7Flow_outFlux: { color: metricColors.l7Flow_outFlux, fontWeight: 500 }
                    }
                  }
                },
                grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                xAxis: { type: 'category', boundaryGap: false, data: timeData },
                yAxis: { type: 'value', name: unit, axisLabel: { color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#6E7079' } }, // Dynamic color for Y-axis label
                series: series
            };
            chartTraffic.setOption(option, true);
        }

        //2.æœ‰ä½¿ç”¨
        function updateBandwidthSection(results) { /* ... unchanged ... */ }
        //3.æœ‰ä½¿ç”¨
        function updateOriginPullSection(results) { /* ... unchanged ... */ }
        
        //4.æœ‰ä½¿ç”¨
        function updateRequestsSection(results) {
            const metrics = metricsConfig.requests;
            const series = [];
            let timeData = [];

            // Calculate global max
            let globalMax = 0;
            metrics.forEach(metric => {
                const data = results[metric];
                if (data && data.type === 'time') {
                    const max = Math.max(...data.valueData);
                    if (max > globalMax) globalMax = max;
                }
            });

            const { unit, divisor } = getBestCountUnit(globalMax);

            metrics.forEach(metric => {
                const data = results[metric];
                if (!data || data.type !== 'time') return;
                
                // Update KPI
                document.getElementById(`kpi_${metric}`).innerText = formatCount(data.sum);

                // Growth
                const prevData = results[metric + '_prev'];
                if (prevData) {
                    renderGrowth(`kpi_${metric}`, data.sum, prevData.sum);
                }

                if (timeData.length === 0) timeData = data.timeData;

                // Chart Data (Dynamic Unit)
                const valueData = data.valueData.map(v => {
                    const val = v / divisor;
                    return (divisor === 1) ? val : val.toFixed(2);
                });

                series.push({
                    name: metricLabels[metric],
                    type: 'line',
                    smooth: true,
                    data: valueData,
                    itemStyle: { color: metricColors[metric] },
                    areaStyle: { opacity: 0.2 },
                    rawData: data.valueData
                });
            });

            const option = {
                tooltip: { trigger: 'axis', formatter: (params) => {
                    let res = params[0].axisValue + '<br/>';
                    params.forEach(param => {
                        const seriesIndex = param.seriesIndex;
                        const dataIndex = param.dataIndex;
                        const rawVal = series[seriesIndex].rawData[dataIndex];
                        const formattedVal = formatCount(rawVal);
                        res += `${param.marker}${param.seriesName}: ${formattedVal}<br/>`;
                    });
                    return res;
                }},
				legend: { 
                    data: metrics.map(m => metricLabels[m]), 
                    bottom: 0,
                    icon: 'circle',
                    formatter: function (name) {
                      const metric = Object.keys(metricLabels).find(k => metricLabels[k] === name);
                      return `{${metric}|${name}}`;
                    },
                    textStyle: {
                      rich: {
                        l7Flow_request: { color: metricColors.l7Flow_request, fontWeight: 500 }
                        // Add other request-related metrics if they become active
                      }
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                xAxis: { type: 'category', boundaryGap: false, data: timeData },
                yAxis: { type: 'value', name: unit, axisLabel: { color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#6E7079' } }, // Dynamic color for Y-axis label
                series: series
            };
            chartRequests.setOption(option);
        }

        //5.æœ‰ä½¿ç”¨
        function updatePerformanceSection(results) { /* ... unchanged ... */ }
        function updateEdgeFunctionsSection(results) { /* ... unchanged ... */ }
        //5.1. Security Section
        function updateSecuritySection(results) { /* ... unchanged ... */ }

        //é€šç”¨å¤„ç†
        const renderTopChart = (results, chartInstance, metricName, mapObject = null) => {
            const data = results[metricName];
            const isDark = document.documentElement.classList.contains('dark'); // Detect theme

            if (!data || data.type !== 'top' || !data.data) return;

            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10);
            
            let unit = '';
            let divisor = 1;
            let label = metricLabels[metricName] || '';
            
            if (metricName.includes('outFlux')) {
                const maxVal = sortedData.length > 0 ? sortedData[0].Value : 0;
                const best = getBestUnit(maxVal, 'bytes');
                unit = best.unit;
                divisor = best.divisor;
            } else {
                const maxVal = sortedData.length > 0 ? sortedData[0].Value : 0;
                const best = getBestCountUnit(maxVal);
                unit = best.unit;
                divisor = best.divisor;
            }

            const yAxisData = sortedData.map(item => mapObject?.[item.Key] || item.Key).reverse(); //é—®é¢˜ç‚¹ï¼šæ²¡å¯¹â€œå­—æ®µä¸å­˜åœ¨â€çš„çŸ­æ¨ªæ åšåˆ¤æ–­
            const seriesData = sortedData.map(item => {
                const val = item.Value / divisor;
                return (divisor === 1) ? val : val.toFixed(2);
            }).reverse();

            let color = '#3b82f6';
            const lowerName = metricName.toLowerCase();
            if (lowerName.includes('country')) color = '#3b82f6';
            else if (lowerName.includes('province') || lowerName.includes('resourcetype') || lowerName.includes('browser')) color = '#f59e0b';
            else if (lowerName.includes('statuscode') || lowerName.includes('referer') || lowerName.endsWith('_ua')) color = '#8b5cf6';
            else if (lowerName.includes('domain') || lowerName.includes('device')) color = '#06b6d4';
            else if (lowerName.includes('url') || lowerName.includes('os')) color = '#10b981';
            else if (lowerName.includes('sip')) color = '#ef4444';

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         let name = param.name;
                         if (name.length > 100) name = name.substring(0, 100) + '...';
                         
                         const rawVal = sortedData[sortedData.length - 1 - param.dataIndex].Value;
                         
                         let formattedVal = '';
                         if (metricName.includes('outFlux')) {
                             formattedVal = formatBytes(rawVal);
                         } else {
                             const fVal = formatCount(rawVal);
                             // Append 'æ¬¡' if not present in unit (formatCount returns unit, but we might want explicit 'æ¬¡')
                             // formatCount returns "1.23 ä¸‡". "1.23 ä¸‡æ¬¡" sounds good.
                             // "500" -> "500 æ¬¡".
                             formattedVal = fVal + (fVal.includes('åƒ') || fVal.includes('ä¸‡') || fVal.includes('äº¿') ? 'æ¬¡' : ' æ¬¡');
                         }
                         
                         return `${name}<br/>${param.marker}${label}: ${formattedVal}`;
                    }
                },
                grid: { left: '3%', right: '10%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: unit, axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } }, // Dynamic color for X-axis label
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079', // Dynamic color for Y-axis label
                        fontWeight: 500,
                        formatter: function (value) {
                            if (value.length > 20) return value.substring(0, 20) + '...';
                            return value;
                        }
                    }
                },
                series: [
                    {
                        name: label,
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: color },
                        label: { 
                            show: true, 
                            position: 'right',
                            backgroundColor: 'transparent',
                            padding: 0,
                            color: isDark ? '#e5e7eb' : '#111827', // Dynamic label color
                            fontWeight: 500
                        }
                    }
                ]
            };
            chartInstance.setOption(option);
        };

        function updateTopMapChart(results) {
            const metric = 'l7Flow_request_country';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Map data to ECharts format
            // IMPORTANT: The 'name' here must match the region name AFTER nameMap is applied.
            // Since worldNameMap maps English names to Chinese (e.g. "China" -> "ä¸­å›½å¤§é™†"),
            // our data points must also use the Chinese names (e.g. "ä¸­å›½å¤§é™†") to match the map regions.
            const mapData = data.data.map(item => {
                const name = countryMap[item.Key] || codeToMapName[item.Key] || item.Key;
                return {
                    name: name,
                    value: item.Value
                };
            });

            const maxVal = mapData.length > 0 ? Math.max(...mapData.map(item => item.value)) : 0;

            const option = {
                tooltip: {
                    trigger: 'item',
                    formatter: function (params) {
                        const val = params.value;
                        return `${params.name}<br/>è¯·æ±‚æ•°: ${val ? val.toLocaleString() : 0} æ¬¡`;
                    }
                },
                visualMap: {
                    min: 0,
                    max: maxVal,
                    left: 'left',
                    top: 'bottom',
                    text: ['High', 'Low'],
                    calculable: true,
                    inRange: {
                        color: ['#e0f2fe', '#0284c7']
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'map',
                        mapType: 'world',
                        roam: true,
                        nameMap: worldNameMap,
                        itemStyle: {
                            emphasis: { label: { show: true } }
                        },
                        data: mapData
                    }
                ]
            };

            chartTopMap.setOption(option);
        }

        //6.æœ‰ä½¿ç”¨
        function updateTopAnalysisSection(results) {
            updateTopMapChart(results);

            // Flux Charts
            renderTopChart(results, chartTopCountry, 'l7Flow_outFlux_country', countryMap);
            renderTopChart(results, chartTopProvince, 'l7Flow_outFlux_province', provinceMap);
            renderTopChart(results, chartTopStatusCode, 'l7Flow_outFlux_statusCode');
            renderTopChart(results, chartTopDomain, 'l7Flow_outFlux_domain');
            renderTopChart(results, chartTopUrl, 'l7Flow_outFlux_url');
			
			// These two are currently inactive with empty metricsConfig.
			// Re-enable if metricsConfig.topAnalysis gets 'l7Flow_outFlux_urlquery' or 'l7Flow_url_res_query'
			renderTopChart(results, chartTopUrlquery, 'l7Flow_outFlux_urlquery');
			renderTopChart(results, chartTopResourceTypequery, 'l7Flow_url_res_query');
			
			
            renderTopChart(results, chartTopResourceType, 'l7Flow_outFlux_resourceType');
            renderTopChart(results, chartTopSip, 'l7Flow_outFlux_sip');
            //renderTopChart(results, chartTopReferer, 'l7Flow_outFlux_referers'); //ä»¥å‰æ–¹æ¡ˆ
            updateTopRefererChart(results); //é™çº§å¤„ç†ï¼ŒåŒ…å«â€œå­—æ®µä¸å­˜åœ¨â€å¤„ç†
            renderTopChart(results, chartTopUaDevice, 'l7Flow_outFlux_ua_device');
            renderTopChart(results, chartTopUaBrowser, 'l7Flow_outFlux_ua_browser');
            renderTopChart(results, chartTopUaOs, 'l7Flow_outFlux_ua_os');
            renderTopChart(results, chartTopUa, 'l7Flow_outFlux_ua');

            // Request Charts
            renderTopChart(results, chartTopRequestCountry, 'l7Flow_request_country', countryMap);
            renderTopChart(results, chartTopRequestProvince, 'l7Flow_request_province', provinceMap);
            renderTopChart(results, chartTopRequestStatusCode, 'l7Flow_request_statusCode');
            renderTopChart(results, chartTopRequestDomain, 'l7Flow_request_domain');
            renderTopChart(results, chartTopRequestUrl, 'l7Flow_request_url');
            renderTopChart(results, chartTopRequestResourceType, 'l7Flow_request_resourceType');
            renderTopChart(results, chartTopRequestSip, 'l7Flow_request_sip');
            //renderTopChart(results, chartTopRequestReferer, 'l7Flow_request_referers');
            updateTopRequestRefererChart(results); //é™çº§æ–¹æ¡ˆ
            renderTopChart(results, chartTopRequestUaDevice, 'l7Flow_request_ua_device');
            renderTopChart(results, chartTopRequestUaBrowser, 'l7Flow_request_ua_browser');
            renderTopChart(results, chartTopRequestUaOs, 'l7Flow_request_ua_os');
            renderTopChart(results, chartTopRequestUa, 'l7Flow_request_ua');
        }



        /**  
         *  ä¸‹é¢è¿™ä¸€å †æˆ‘ä¹Ÿä¸çŸ¥é“æ˜¯å¹²å˜›çš„
         *  å¯èƒ½æ˜¯äºŒå‰è„†è„†é—ç•™ä¸‹çš„é™çº§æ–¹æ¡ˆå§
         *  å…ˆä¸åˆ äº†ï¼Œçœçš„å†å‡ºé—®é¢˜
         *  ä¸è¿‡å€’æ˜¯å¯ä»¥å…ˆç•™ç€ä¹Ÿæ˜¯ï¼Œè¯´ä¸å®šåé¢å¯èƒ½ä¼šç”¨åˆ°ï¼Ÿ
         *  çœŸçš„å¤ªç¥ç§˜äº†
         * **/

        function updateTopCountryChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_country';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => countryMap[item.Key] || item.Key).reverse(); // Countries
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#3b82f6' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopCountry.setOption(option);
        }

        function updateTopProvinceChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_province';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => provinceMap[item.Key] || item.Key).reverse(); // Map ID to Province Name
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' }, // Amber
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopProvince.setOption(option);
        }

        function updateTopStatusCodeChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_statusCode';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse(); // Status Codes
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' }, // Purple
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopStatusCode.setOption(option);
        }

        function updateTopDomainChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_domain';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse(); // Domains
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#06b6d4' }, // Cyan
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopDomain.setOption(option);
        }

        function updateTopUrlChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_url';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse(); // URLs
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         // Truncate long URLs in tooltip if needed, but usually full URL is better
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500,
                        formatter: function (value) {
                            // Truncate long URLs in axis label
                            if (value.length > 30) {
                                return value.substring(0, 30) + '...';
                            }
                            return value;
                        }
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#10b981' }, // Green
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopUrl.setOption(option);
        }
		
        function updateTopResourceTypeChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_resourceType';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse(); // Resource Types
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' }, // Amber
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopResourceType.setOption(option);
        }

        function updateTopSipChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_sip';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse(); // Client IPs
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#ef4444' }, // Red
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopSip.setOption(option);
        }

        //æ— è°ƒç”¨ï¼Œä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆæ¥å¤„ç†
        function updateTopRefererChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_referers';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => {
                // Clean up key: remove backticks and trim
                let key = item.Key.replace(/`/g, '').trim();
                if (!key || key === '-') return 'å­—æ®µä¸å­˜åœ¨'; //æ— /ç›´æ¥è®¿é—®
                return key;
            }).reverse();
            
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500,
                        formatter: function (value) {
                            // Truncate long URLs
                            if (value.length > 30) {
                                return value.substring(0, 30) + '...';
                            }
                            return value;
                        }
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' }, // Purple
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopReferer.setOption(option);
        }

        function updateTopUaDeviceChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_ua_device';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#06b6d4' }, // Cyan
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopUaDevice.setOption(option);
        }

        function updateTopUaBrowserChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_ua_browser';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' }, // Amber
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopUaBrowser.setOption(option);
        }

        function updateTopUaOsChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_ua_os';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#10b981' }, // Green
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopUaOs.setOption(option);
        }

        function updateTopUaChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_outFlux_ua';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key.substring(0, 50) + (item.Key.length > 50 ? '...' : '')).reverse(); // Truncate long UAs
            const seriesData = sortedData.map(item => (item.Value / (1024 * 1024 * 1024)).toFixed(2)).reverse(); // GB

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         // Find full UA string
                         const originalItem = sortedData.find((item, index) => index === (sortedData.length - 1 - param.dataIndex));
                         const fullName = originalItem ? originalItem.Key : param.name;
                         return `${fullName}<br/>${param.marker}æµé‡: ${param.value} GB`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'GB', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData, 
                    axisLabel: { 
                        interval: 0, 
                        width: 200, 
                        overflow: 'truncate',
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    } 
                },
                series: [
                    {
                        name: 'æµé‡',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' }, // Purple
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopUa.setOption(option);
        }

        function updateTopRequestCountryChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_country';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => countryMap[item.Key] || item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#3b82f6' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestCountry.setOption(option);
        }

        function updateTopRequestProvinceChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_province';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => provinceMap[item.Key] || item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestProvince.setOption(option);
        }

        function updateTopRequestStatusCodeChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_statusCode';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestStatusCode.setOption(option);
        }

        function updateTopRequestDomainChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_domain';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData, 
                    axisLabel: { 
                        interval: 0, 
                        width: 200, 
                        overflow: 'truncate',
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    } 
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#06b6d4' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestDomain.setOption(option);
        }

        function updateTopRequestUrlChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_url';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData, 
                    axisLabel: { 
                        interval: 0, 
                        width: 200, 
                        overflow: 'truncate',
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    } 
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#10b981' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestUrl.setOption(option);
        }

        function updateTopResourceTypeChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_resourceType';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestResourceType.setOption(option);
        }

        function updateTopRequestSipChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_sip';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestSip.setOption(option);
        }

        //æ— è°ƒç”¨ï¼Œä½œä¸ºå¤‡ä»½ä½¿ç”¨
        function updateTopRequestRefererChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_referers';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => {
                 let key = item.Key;
                 if (key === '-') return 'å­—æ®µä¸å­˜åœ¨'; //ç›´æ¥è®¿é—®
                 // Clean up backticks and extra spaces
                 key = key.replace(/`/g, '').trim();
                 return key.substring(0, 50) + (key.length > 50 ? '...' : '');
            }).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         // Find full referer string
                         const originalItem = sortedData.find((item, index) => index === (sortedData.length - 1 - param.dataIndex));
                         let fullName = param.name;
                         if (originalItem) {
                             let key = originalItem.Key;
                             if (key === '-') fullName = 'å­—æ®µä¸å­˜åœ¨'; //ç›´æ¥è®¿é—®
                             else fullName = key.replace(/`/g, '').trim();
                         }
                         return `${fullName}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData, 
                    axisLabel: { 
                        interval: 0, 
                        width: 200, 
                        overflow: 'truncate',
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    } 
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#ec4899' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestReferer.setOption(option);
        }

        function updateTopRequestUaDeviceChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_ua_device';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#06b6d4' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestUaDevice.setOption(option);
        }

        function updateTopRequestUaBrowserChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_ua_browser';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#10b981' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestUaBrowser.setOption(option);
        }

        function updateTopRequestUaOsChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_ua_os';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key).reverse();
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         return `${param.name}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData,
                    axisLabel: {
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    }
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#f59e0b' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestUaOs.setOption(option);
        }

        function updateTopRequestUaChart(results) {
            const isDark = document.documentElement.classList.contains('dark');
            const metric = 'l7Flow_request_ua';
            const data = results[metric];

            if (!data || data.type !== 'top' || !data.data) return;

            // Sort by value (descending)
            const sortedData = [...data.data].sort((a, b) => b.Value - a.Value).slice(0, 10); // Top 10

            const yAxisData = sortedData.map(item => item.Key.substring(0, 50) + (item.Key.length > 50 ? '...' : '')).reverse(); // Truncate long UAs
            const seriesData = sortedData.map(item => item.Value).reverse();

            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params) => {
                         const param = params[0];
                         // Find full UA string
                         const originalItem = sortedData.find((item, index) => index === (sortedData.length - 1 - param.dataIndex));
                         const fullName = originalItem ? originalItem.Key : param.name;
                         return `${fullName}<br/>${param.marker}è¯·æ±‚æ•°: ${param.value.toLocaleString()} æ¬¡`;
                    }
                },
                grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                xAxis: { type: 'value', name: 'æ¬¡', axisLabel: { color: isDark ? '#e5e7eb' : '#6E7079' } },
                yAxis: { 
                    type: 'category', 
                    data: yAxisData, 
                    axisLabel: { 
                        interval: 0, 
                        width: 200, 
                        overflow: 'truncate',
                        color: isDark ? '#e5e7eb' : '#6E7079',
                        fontWeight: 500
                    } 
                },
                series: [
                    {
                        name: 'è¯·æ±‚æ•°',
                        type: 'bar',
                        data: seriesData,
                        itemStyle: { color: '#8b5cf6' },
                        label: { show: true, position: 'right', backgroundColor: 'transparent', padding: 0, color: isDark ? '#e5e7eb' : '#111827', fontWeight: 500 }
                    }
                ]
            };

            chartTopRequestUa.setOption(option);
        }
        /** ç¥ç§˜é™çº§æ–¹æ¡ˆç»“æŸ **/

        // Handle Resize
        window.addEventListener('resize', () => {
            chartTraffic && chartTraffic.resize();
            chartRequests && chartRequests.resize();
            // Removed commented out charts from cf.html that are not used in ESA.html
            chartTopCountry && chartTopCountry.resize();
            chartTopProvince && chartTopProvince.resize();
            chartTopStatusCode && chartTopStatusCode.resize();
            chartTopDomain && chartTopDomain.resize();
            chartTopUrl && chartTopUrl.resize();			
			chartTopUrlquery && chartTopUrlquery.resize();
			chartTopResourceTypequery && chartTopResourceTypequery.resize();			
            chartTopResourceType && chartTopResourceType.resize();
            chartTopSip && chartTopSip.resize();
            chartTopReferer && chartTopReferer.resize();
            chartTopUaDevice && chartTopUaDevice.resize();
            chartTopUaBrowser && chartTopUaBrowser.resize();
            chartTopUaOs && chartTopUaOs.resize();
            chartTopUa && chartTopUa.resize();
            chartTopRequestCountry && chartTopRequestCountry.resize();
            chartTopRequestProvince && chartTopRequestProvince.resize();
            chartTopRequestStatusCode && chartTopRequestStatusCode.resize();
            chartTopRequestDomain && chartTopRequestDomain.resize();
            chartTopRequestUrl && chartTopRequestUrl.resize();
            chartTopRequestResourceType && chartTopRequestResourceType.resize();
            chartTopRequestSip && chartTopRequestSip.resize();
            chartTopRequestReferer && chartTopRequestReferer.resize();
            chartTopRequestUaDevice && chartTopRequestUaDevice.resize();
            chartTopRequestUaBrowser && chartTopRequestUaBrowser.resize();
            chartTopRequestUaOs && chartTopRequestUaOs.resize();
            chartTopRequestUa && chartTopRequestUa.resize();
            chartTopMap && chartTopMap.resize();
        });

        // ğŸŒ™ å¤œé—´æ¨¡å¼é€»è¾‘
        function applyTheme(theme) {
            const html = document.documentElement;
            const btn = document.getElementById('themeToggle');

            if (theme === 'dark') {
                html.classList.add('dark');
                btn.innerText = 'â˜€ï¸ æ—¥é—´æ¨¡å¼';
            } else {
                html.classList.remove('dark');
                btn.innerText = 'ğŸŒ™ å¤œé—´æ¨¡å¼';
            }

            localStorage.setItem('theme', theme);

            // åˆ·æ–° ECharts ä¸»é¢˜ï¼ˆé‡è¦ï¼‰
            setTimeout(() => {
               rerenderChartsByTheme(); // â­ åªé‡ç»˜æ ·å¼
            }, 50);
        }

        function toggleTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            applyTheme(isDark ? 'light' : 'dark');
        }



        function rerenderChartsByTheme() {
          if (!lastResults) return;

          // Call all relevant update functions to re-apply ECharts options with theme-aware colors.
          updateTrafficSection(lastResults);
          updateRequestsSection(lastResults);
          updateTopAnalysisSection(lastResults);


        }

        // Start - Entrance
        initDashboard();
    </script>
</body>
</html>
